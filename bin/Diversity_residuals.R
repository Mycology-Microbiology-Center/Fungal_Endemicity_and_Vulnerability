#!/usr/bin/env Rscript

## Estimate diversity residuals on a grid
## Input = model-based predictions, observed values, grid points for prediction

## Usage:
# ./Diversity_residuals.R \
#    --data "FOR_PREDICTION.xlsx" \
#    --sheet "GSMc" \
#    --var "RES_LOG_ectomycorrhizal_Richness" \
#    --raster "ECM__LT_LinearModel.tif" \
#    --grid "Grid_1.RData" \
#    --idwpower 2


# IDW: Higher power value (`idwpower`) puts more emphasis on the nearest points.
#      Thus, nearby data will have the most influence, and the surface will have more detail (be less smooth).
#      As the power increases, the interpolated values begin to approach the value of the nearest sample point.
#      Specifying a lower value for power will give more influence to surrounding points that are farther away,
#      resulting in a smoother surface.

############################################## Parse input parameters

## Check time
start_time <- Sys.time()

cat("Parsing input options and arguments...\n")

suppressPackageStartupMessages(require(optparse)) # don't say "Loading required package: optparse"

## Parse arguments
option_list <- list(
  make_option(c("-d", "--data"), action="store", default=NA, type='character', help="Excel file with observed values"),
  make_option(c("-s", "--sheet"), action="store", default=NA, type='character', help="Sheet name in the xlsx file"),
  make_option(c("-v", "--var"), action="store", default=NA, type='character', help="Variable name (observed diversity)"),
  make_option(c("-r", "--raster"), action="store", default=NA, type='character', help="Model-based predictions (tif)"),
  make_option(c("-g", "--grid"), action="store", default=NA, type='character', help="Grid for prediction"),
  make_option(c("-p", "--idwpower"), action="store", default=2, type='double', help="Inverse distance weighting power")
)
opt <- parse_args(OptionParser(option_list=option_list))

## Validation
# if(is.na(opt$input)){
#   cat("Input file is not specified.\n", file=stderr())
#   stop()
# }

## Assign variables
DATA <- opt$data
SHEET <- opt$sheet
VAR <- opt$var
RASTER <- opt$raster
GRID <- opt$grid
IDWPOWER <- opt$idwpower

## Output prefix
OUTPUT <- paste(SHEET, VAR, IDWPOWER, basename(GRID), sep = "__")
#   e.g., "GSMc__RES_LOG_ectomycorrhizal_Richness__2__Grid_1.RData"

## Log assigned variables
cat(paste("Observed data: ", DATA, "\n", sep=""))
cat(paste("Sheet name: ", SHEET, "\n", sep=""))
cat(paste("Variable name: ", VAR, "\n", sep=""))
cat(paste("Raster name: ", RASTER, "\n", sep=""))
cat(paste("Grid name: ", GRID, "\n", sep=""))
cat(paste("IDW power: ", IDWPOWER, "\n", sep=""))
cat(paste("Output file: ", OUTPUT, "\n", sep=""))

cat("\n")

############################################## Load packages

cat("Loading packages...\n")

load_pckg <- function(pkg = "raster"){
  suppressPackageStartupMessages( library(package = pkg, character.only = TRUE) )
  cat(paste(pkg, packageVersion(pkg), "\n"))  
}

load_pckg("data.table")
load_pckg("sp")
load_pckg("sf")
load_pckg("raster")
load_pckg("gstat")

cat("\n")



############################################## Main workflow

## Main function
calc_resids <- function(
  datt, sheet, dependvar = "RES_LOG_ectomycorrhizal_Richness",
  rs, grid, idwpower = 2){

  # e.g.
  # datt <- "data_for_prediction.xlsx"; sheet <- "GSMc"
  # dependvar <- "RES_LOG_ectomycorrhizal_Richness"
  # rs <- "ECM__LT_LinearModel.tif"
  # grid <- "GridChunks/Grid_1.RData"
  # idwpower = 2

  ## Load raster with model-based predictions
  cat("Loading raster with predictions...\n")
  rs <- raster(rs)

  ## Load points for residuals interpolation (one of the chunks)
  cat("Loading new prediction grid...\n")
  grid <- readRDS(grid)

  ## Load data with observed values
  cat("Loading observed data...\n")
  datt <- readxl::read_excel(
    path = datt, sheet = sheet,
    na = c("", " ", "NA", "#N/A", "ND"))

  ## Remove missing values
  if(any(is.na(datt[, dependvar, drop = TRUE]))){
    datt <- datt[ !is.na(datt[, dependvar, drop = TRUE]), ]
  }

  ## Extract predicted values from the raster
  cat("Creating SpatialPointsDataFrame...\n")
  xy <- SpatialPointsDataFrame(
    coords = datt[, c("longitude", "latitude")],
    data = datt[, c("SampleID", "longitude", "latitude", dependvar)],
    proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))

  names(xy)[ length(names(xy)) ] <- "Observed"
  xy$Predicted <- extract(rs, xy)

  ## Estimate residuals
  cat("Estimating residuals...\n")
  xy$Residuals <- xy$Observed - xy$Predicted

  ## Remove missing values
  if(any(is.na(xy$Residuals))){
    cat("Missing value removal...\n")
    xy <- xy[!is.na(xy$Residuals), ]
  }

  ## Inverse distance weighted interpolation
  cat("Interpolating residuals to a grid...\n")
  KRG <- gstat::idw(
        formula = Residuals ~ 1,
        locations = xy,
        newdata = grid,
        idp = idwpower
        )

  cat("Preparing results...\n")
  res <- data.table(
    coordinates(grid),
    cell = grid$cell,
    Residuals = KRG$var1.pred)

  return(res)
}


RES <- calc_resids(
  datt = DATA,
  sheet = SHEET,
  dependvar = VAR,
  rs = RASTER,
  grid = GRID,
  idwpower = IDWPOWER)


cat("\nSaving results...\n")
saveRDS(
  object = RES,
  file = OUTPUT,
  compress = "xz")


## Check time
end_time <- Sys.time()

tmm <- as.numeric(difftime(end_time, start_time, units = "min"))
cat("\nElapsed time: ", tmm, " minutes\n")


cat("\n")
cat("Session info:\n")
sessionInfo()
cat("\n")


#!/usr/bin/env Rscript

## Script to fit the model (LM of GAM)
## for vulnerability indices (t1,t2, and t3, as well as Z-score transformed indices)
## and perform spatial model predictions

## Usage:
# ./Vulnerability_script_map.R \
#    --input "Inds__primary_lifestyle_ectomycorrhizal__MAP" \
#    --tiff "CHELSA_bio12_1981-2010_V.2.1.tif" \
#    --suff "_Current" \
#    --transf "log" \
#    --model "gam"


## NB! `EnvValue` in Inds_* file should be already transformed
##     --> need to apply the same transformation to the raster file

############################################## Parse input parameters

cat("Parsing input options and arguments...\n")

suppressPackageStartupMessages(require(optparse)) # don't say "Loading required package: optparse"

## Parse arguments
option_list <- list(
  make_option(c("-i", "--input"), action="store", default=NA, type='character', help="Input file name with vulnerability indices"),
  make_option(c("-t", "--tiff"), action="store", default=NA, type='character', help="Name of the GTiff file with predictor"),
  make_option(c("-s", "--suff"), action="store", default="", type='character', help="Output file suffix"),
  make_option(c("-r", "--transf"), action="store", default="none", type='character', help="Predictor transformation type"),
  make_option(c("-m", "--model"), action="store", default="gam", type='character', help="Regression model type")
  # , make_option(c("-h", "--help"), action="store_true", default=FALSE, help="Show this help message and exit")
)
opt <- parse_args(OptionParser(option_list=option_list))

## Validation
if(is.na(opt$input)){
  cat("Input file is not specified.\n", file=stderr())
  stop()
}
if(is.na(opt$tiff)){
  cat("Environmental variable is not specified.\n", file=stderr())
  stop()
}

## Assign variables
INPUTFILE <- opt$input
TIFF <- opt$tiff
SUFF <- opt$suff
TRANSF <- opt$transf
MDD <- opt$model

## Log assigned variables
cat(paste("Input file: ", INPUTFILE, "\n", sep=""))
cat(paste("Tiff file: ", TIFF, "\n", sep=""))
cat(paste("Output file suffix: ", SUFF, "\n", sep=""))
cat(paste("Transformation type: ", TRANSF, "\n", sep=""))
cat(paste("Model type: ", MDD, "\n", sep=""))
cat("\n")

############################################## Load packages

cat("Loading packages...\n")

# suppressPackageStartupMessages( library(data.table) ); cat(paste("data.table", packageVersion("data.table"), "\n"))
suppressPackageStartupMessages( library(raster) ); cat(paste("raster", packageVersion("raster"), "\n"))
suppressPackageStartupMessages( library(ggplot2) ); cat(paste("ggplot2", packageVersion("ggplot2"), "\n"))
suppressPackageStartupMessages( library(patchwork) ); cat(paste("patchwork", packageVersion("patchwork"), "\n"))
suppressPackageStartupMessages( library(mgcv) ); cat(paste("mgcv", packageVersion("mgcv"), "\n"))
suppressPackageStartupMessages( library(gratia) ); cat(paste("gratia", packageVersion("gratia"), "\n"))

cat("\n")

set.seed(14789)
theme_set(theme_classic(base_size = 14))


############################################## Vulnerability indices

# t1 = 1st vulnerability index, describing the proportion of observed species which are vulnerable.
# t2 = 2nd vulnerability index, describing the community-mean percentile at the observed site.
# t3 = 3rd vulnerability index, describing the safety margin as the deviation of community-mean upper y limits from the observed y value.

# bioclim variables:
# 1   = Annual Mean Temperature [°C*10]
# 2   = Mean Diurnal Range [°C]
# 3   = Isothermality
# 4   = Temperature Seasonality [standard deviation]
# 5   = Max Temperature of Warmest Month [°C*10]
# 6   = Min Temperature of Coldest Month [°C*10]
# 7   = Temperature Annual Range [°C*10]
# 8   = Mean Temperature of Wettest Quarter [°C*10]
# 9   = Mean Temperature of Driest Quarter [°C*10]
# 10  = Mean Temperature of Warmest Quarter [°C*10]
# 11  = Mean Temperature of Coldest Quarter [°C*10]
# 12  = Annual Precipitation [mm/year]
# 13  = Precipitation of Wettest Month [mm/month]
# 14  = Precipitation of Driest Month [mm/month]
# 15  = Precipitation Seasonality [coefficient of variation]
# 16  = Precipitation of Wettest Quarter [mm/quarter]
# 17  = Precipitation of Driest Quarter [mm/quarter]
# 18  = Precipitation of Warmest Quarter [mm/quarter]
# 19  = Precipitation of Coldest Quarter [mm/quarter]


## Function to predict vulnerability indces and project them on a map
predict_map <- function(vulnerab_ind, tiff, transformation = "none", model_type = "gam", res_suff = ""){
  # vulnerab_ind = "Inds__primary_lifestyle_ectomycorrhizal__AnnMeanTemp.RData"
  # tiff = "CHELSA_bio10_1.tif"
  # res_suff = suffix to add to the results name

  ## Load vulerability indices
  cat("..Loading vulnerabilty indices\n")
  inds <- readRDS(vulnerab_ind)
  # colnames(inds)[ which(colnames(inds) %in% "EnvValue") ] <- "values"

  cat("..Cleaning data\n")

  ## Remove Antarctic sample
  if("S442" %in% inds$SampleID_Endemism){
    inds <- inds[ - which(inds$SampleID_Endemism %in% "S442"), ]
  }
  
  ## Remove missing values
  if(any(is.na(inds$EnvValue))){
    inds <- inds[ !is.na(inds$EnvValue), ]
  }
  if(any(is.infinite(inds$EnvValue))){
    inds <- inds[ !is.infinite(inds$EnvValue), ]
  }

  # if(any(is.na(inds$t1))){
  #   inds <- inds[ !is.na(inds$t1), ]
  # }
  # if(any(is.infinite(inds$t1))){
  #   inds <- inds[ !is.infinite(inds$t1), ]
  # }


  ## Create combined index
  cat("..Z-score estimation\n")
  inds$t1_z <- scale(inds$t1, center = T, scale = T)
  inds$t2_z <- scale(inds$t2, center = T, scale = T)
  inds$t3_z <- scale(inds$t3, center = FALSE, scale = T)   # do not center to preserve the sign of t3!
  inds$t123z <- rowMeans(inds[, c("t1_z", "t2_z", "t3_z")])
  # cor(inds[, c("t1","t2","t3", "t123z")])

  ## Results name
  nm <- paste(
    inds$Funct_group[1],     # fungal group (e.g., "ECM")
    inds$Variable[1],        # predictor (e.g., "MAT")
    transformation,          # transformation type (e.g. "log")
    model_type,              # model type (e.g., "lm" or "gam")
    res_suff,                # additional suffix (e.g., "current" or "future")
    sep = "_")

  ## Load GIS data
  cat("..Loading raster\n")
  rst <- raster(tiff)

  ## Transform raster
  if(transformation %in% "none"){
    ## No transformation required
    stk <- stack(rst)
  } else {
    cat("..Transforming raster with ", transformation, "\n")

    if(transformation == "log"){ stk <- stack( log1p(rst) ) }
    if(transformation == "symlog"){ stk <- stack( sign(rst) * log1p(abs(rst)) ) }
    if(transformation == "asinh"){ stk <- stack( -1 * asinh(rst) ) }
    if(transformation == "inv"){ stk <- stack( -1 * rst ) }
    if(transformation == "symsqrt"){ stk <- stack( sign(rst) * sqrt(abs(rst)) ) }

    cat("..Raster transformation done\n")
  }

  ## Rename variable
  names(stk) <- "EnvValue"

  ## Convert to a matrix
  # sdata = as.matrix(as.data.frame(stk))

  ## Model
  cat("..Model fitting\n")
  if(model_type == "lm"){
    mod_t1 <- lm(t1 ~ EnvValue, data = inds)
    mod_t2 <- lm(t2 ~ EnvValue, data = inds)
    mod_t3 <- lm(t3 ~ EnvValue, data = inds)
    mod_tz <- lm(t123z ~ EnvValue, data = inds)
  }
  # plot(effects::allEffects(mod_t1))
  # ggplot(data = inds, aes(x = EnvValue, y = t1)) + geom_point() + geom_smooth(method = "lm")

  if(model_type == "gam"){
    mod_t1 <- gam(t1 ~ s(EnvValue, k = 3), family=gaussian(), data = inds)
    mod_t2 <- gam(t2 ~ s(EnvValue, k = 3), family=gaussian(), data = inds)
    mod_t3 <- gam(t3 ~ s(EnvValue, k = 3), family=gaussian(), data = inds)

    mod_t1z <- gam(t1_z ~ s(EnvValue, k = 3), family=gaussian(), data = inds)
    mod_t2z <- gam(t2_z ~ s(EnvValue, k = 3), family=gaussian(), data = inds)
    mod_t3z <- gam(t3_z ~ s(EnvValue, k = 3), family=gaussian(), data = inds)

    mod_tz <- gam(t123z ~ s(EnvValue, k = 3), family=gaussian(), data = inds)
  }

  ## Export models
  modz <- list()
  modz$mod_t1 <- mod_t1
  modz$mod_t2 <- mod_t2
  modz$mod_t3 <- mod_t3
  modz$mod_t1z <- mod_t1z
  modz$mod_t2z <- mod_t2z
  modz$mod_t3z <- mod_t3z
  modz$mod_tz <- mod_tz

  cat("..Exporting models\n")
  saveRDS(object = modz, file = paste0(nm, "_models.RData"), compress = "xz")

  cat("..Plotting effects\n")
  if(model_type == "gam"){
    
    eff_1 <- draw(mod_t1) + labs(x = inds$Variable[1], y = "t1") + ggtitle("t1")
    eff_2 <- draw(mod_t2) + labs(x = inds$Variable[1], y = "t2") + ggtitle("t2")
    eff_3 <- draw(mod_t3) + labs(x = inds$Variable[1], y = "t3") + ggtitle("t3")

    eff_1z <- draw(mod_t1z) + labs(x = inds$Variable[1], y = "z(t1)") + ggtitle("Z - t1")
    eff_2z <- draw(mod_t2z) + labs(x = inds$Variable[1], y = "z(t2)") + ggtitle("Z - t2")
    eff_3z <- draw(mod_t3z) + labs(x = inds$Variable[1], y = "z(t3)") + ggtitle("Z - t3")

    eff_z <- draw(mod_tz) + labs(x = inds$Variable[1], y = "Z") + ggtitle("Avg Z")

    eff <- eff_1 + eff_2 + eff_3 +
           eff_1z + eff_2z + eff_3z +
           eff_z +
           plot_layout(ncol = 3, nrow = 3)

    ggsave(filename = paste0(nm, "_EffectPlots.pdf"),
      plot = eff, width = 16, height = 14, useDingbats = FALSE)
  }

  ## Predict
  my_pred <- function(mod, yname = "_t1", censore = FALSE){

    ## Predict average and uncertainty (SE)
    predfun <- function(model, data) {
      v <- predict(model, data, se.fit=TRUE)
      cbind(avg = as.vector(v$fit), se = as.vector(v$se.fit))
    }

    ## Predict average only
    # predd <- raster::predict(model = mod, object = stk, progress='text')
    
    ## Predfun returns two variables, so use index=1:2
    predd <- raster::predict(object = stk, model = mod, fun = predfun, index=1:2)

    ## Censore the predictions (limit t1 and t2 predictions in [0,100] range)
    cens <- function(r){
      values(r)[ values(r) < 0 ] <- 0
      values(r)[ values(r) > 100 ] <- 100
      return(r)
    }
  
    if(censore == TRUE){
      predd[[1]] <- cens(predd[[1]])   # censore only avg
    }

    ## Export raster
    writeRaster(x = predd,
      filename = paste0(nm, yname),
      format='GTiff', options=c("COMPRESS=DEFLATE", "PREDICTOR=2", "ZLEVEL=9")
      )

    ## Clean up
    rm(mod, predd)
    gc()
  }

  ## Predict different indices
  cat("..Predicting t1\n")
  my_pred(mod = mod_t1, yname = "_t1", censore = TRUE)
  cat("..Predicting t2\n")
  my_pred(mod = mod_t2, yname = "_t2", censore = TRUE)
  cat("..Predicting t3\n")
  my_pred(mod = mod_t3, yname = "_t3", censore = FALSE)

  cat("..Predicting t1z\n")
  my_pred(mod = mod_t1z, yname = "_t1z", censore = FALSE)
  cat("..Predicting t2z\n")
  my_pred(mod = mod_t2z, yname = "_t2z", censore = FALSE)
  cat("..Predicting t3z\n")
  my_pred(mod = mod_t3z, yname = "_t3z", censore = FALSE)

  cat("..Predicting Z\n")
  my_pred(mod = mod_tz, yname = "_z", censore = FALSE)

  ## Clean up
  rm(rst, stk); gc()

  ## Return models
  invisible(modz)

} # end of `predict_map`


## Check time
start_time <- Sys.time()

## Perform the analysis
predict_map(
  vulnerab_ind = INPUTFILE,
  tiff = TIFF,
  res_suff = SUFF,
  transformation = TRANSF,
  model_type = MDD)

## Check time
end_time <- Sys.time()

tmm <- as.numeric(difftime(end_time, start_time, units = "min"))
cat("\nElapsed time: ", tmm, " minutes\n")


cat("\n")
cat("Session info:\n")
sessionInfo()
cat("\n")

